  
[[repoman]]
== Component Lifecycle and Repository Management

=== Introduction

Component Lifecycle Management (CLM) in general and specifically the
subset Repository Management are two aspects of current software
development best practices that are closely related to Nexus usage. In
this chapter you will learn more about CLM and repository management
and how you can take advantage of Nexus features to implement these
best practices.

[[clm]]
=== Component Lifecycle Management

Component lifecycle management can be defined as the practice of
 analysis, control, and monitoring of all components used in your
 software development lifecycle.

It has emerged as a new category of software development products,
information services and practices that help managing agile,
collaborative, component-based development efforts. They allows you to
ensure the integrity of the modern software supply chain, amplifying
the benefits of modern development, while reducing risk.

==== Increasing Component Usage and Open Source Components

Modern software development practices have shifted dramatically from
large efforts of writing new code to the usage of components to
assemble applications. This approach limits the amount of code
authorship to the business specific aspects of your software. 

A large number of open source components in the form of libraries,
reusable widgets or whole applicatione, application servers and others
is now available featuring very high levels of quality and feature
sets, that could not be implemented as a side effect of your business
application development. E.g. creating a new web application framework
and business workflow system just to create a website with a
publishing workflow would be extremely inefficient.

Open source has become an integral part of modern applications in this
form of components. A typical enterprise application is comprised of
tens, if not hundreds, of components accounting for 80% and more of the
application.

==== Security Vulnerability and License Compliance Risks

With the huge benefits derived from using open source as well as
commercial components, comes the complexity of understanding all the
implications to your software delivery. These include security
vulnerabilities, license compliance problems as well as quality
issues, that need to be managed through the whole life cycle starting
at the inception of the sofware all the way through development,
qualitiy assurance, production deployments and onwards until the
decommissioning of the software. 

The number of components, their rapid change rate with new releases as
well as the ease of adding new dependencies, make the management and
full understanding of all involved components a task, that can not be
carried out manually and requires the assistance of tools such as
Nexus and Sonatype Insight.

==== Nexus and Component Lifecycle Management

Nexus provides a number of tools that can help you in your CLM
efforts. Besides focussing on being a component repository manager it
includes features such as the display of security vulnerabilities as
well as license analysis results within search results and the
Repository Health Check reports for a proxy repository. 

Specific examples about using Nexus for CLM related tasks can be found
in <<rhc>>.

Nexus Professional secures your component supply chain as documented
in <<confignx-sect-secure-central>>, which forms an important base
for your CLM efforts.


[[repoman-sect-intro]]
=== Repository Management

Repository Management is a critical practice that is part of your
Component Lifecycle Managment implementation.  Without repository
management your component usage is effectively out of control and can
not be governed and managed. This makes it impossible to track
security, license and quality issues you are exposed to due to the
components you use from your source code, through your build
environments and releases to production usage.

Repository managers serve two purposes: they act as highly
configurable proxies between your organization and the public 
repositories and they provide an organization with a deployment
destination for its own generated artifacts. Just as Source Code
Management (SCM) tools are designed to manage source artifacts,
repository managers have been designed to manage and track external
dependencies and artifacts generated by your build. They are an
essential part of any enterprise or open-source software development
effort, and they enable greater collaboration between developers and
wider distribution of software.

==== Proxying Public Repositories

Proxying and caching a remote public repository can speed up your
builds by reducing redundant downloads over the public Internet.  If a
developer in your organization needs to download version 2.5 of the
Spring Framework and you are using Nexus, the dependencies (and the
dependency's dependencies) only need to be downloaded from the remote
repository once.

With a high-speed connection to the Internet this might seem like a
minor concern, but if you are constantly asking your developers to
download hundreds of megabytes of third-party dependencies, the real
cost savings are going to be the time it takes Maven to check for new
versions of dependencies and to download dependencies over the public
Internet.

Proxying and serving Maven dependencies from a local repository cache
can save you hundreds of HTTP requests over the public Internet, and,
in very large multi-module projects, this can shave minutes from a
build.

==== Managing Releases and Snapshots

If your project is relying on a number of SNAPSHOT dependencies, Maven
will need to regularly check for updated versions of these
snapshots. Depending on the configuration of your remote repositories,
Maven will check for SNAPSHOT updates periodically, or it might be
checking for SNAPSHOT updates on every build. When Maven checks for a
snapshot update it needs to interrogate the remote repository for the
latest version of the SNAPSHOT dependency. Depending on your
connection to the public Internet and the load on the Maven Central
repository, a SNAPSHOT update can add seconds to your project's build
for each SNAPSHOT dependency you rely upon.

When you host a local repository proxy with Nexus, you reduce the
amount of time it takes for Maven to check for a newer version as your
build interacts with a local repository cache. If you develop software
with SNAPSHOT dependencies, using a local repository manager will save
you a considerable amount of time, your 5-10 second SNAPSHOT update
checks against the public central repository are going to execute in
hundreds of milliseconds (or less) when they are executed against a
local resource.

==== Getting Control of Dependencies

In addition to the simple savings in time and bandwidth, a repository
manager provides an organization with control over what is downloaded
by Maven. You can include or exclude specific artifacts from the
public repository, and having this level of control over what is
downloaded from the Maven Central repository is a prerequisite for
many organizations which have a need for strict standards for the
quality and security of the dependencies used in an enterprise system.

If you want to standardize on a specific version of a dependency like
Hibernate or Spring you can enforce this standardization by only
providing access to a specific version of an artifact in Nexus.  You
might be concerned with making sure that every external dependency has
a license compatible with your legal standards for adopting and
integrating open source libraries. If you are producing an application
which is distributed, you might want to make sure that no one
inadvertently adds a dependency on a third-party library covered under
a copy-left license like the GPL. All of this is possible with Nexus.

Repository managers are a central point of access to external binary
software artifacts and dependencies your system relies upon. Nexus
provides a level of control that is essential when you are trying to
track and manage the libraries and frameworks your software depends
upon.

==== A Nexus for Collaboration

Aside from the benefits of mediating access to remote repositories, a
repository manager also provides an important platform for
collaborative software development. Unless you expect every member of
your organization to download and build every single internal project
from source, you will want to provide a mechanism for developers and
departments to share binary artifacts (both SNAPSHOTs and releases)
for internal software projects. Internal groups often consume the APIs
and systems which are generated by other internal groups, when you
adopt Nexus as a deployment platform for internal artifacts, you can
easily share components and libraries between groups of developers.

Nexus provides you with a deployment target for your software
components. Once you install Nexus, you can start using Maven to
deploy snapshots and releases to internal repositories which can then
be combined with other repositories in repository groups. Over time,
this central deployment point for internal projects becomes the fabric
for collaboration between different development teams and
operations. Nexus is the secret ingredient that allows an organization
to scale its development effort without sacrificing agility.

[[repoman-sect-repo]]
=== What is a Repository?

Maven developers are familiar with the concept of a repository: a
collection of binary software artifacts and metadata stored in a
defined directory structure which is used by clients such as Apache
Ivy to retrieve binaries during a build process. In the case of the
Maven repository, the primary type of binary artifact is a JAR file
containing Java bytecode, but there is no limit to what type of
artifact can be stored in a Maven repository. For example, one could
just as easily deploy documentation archives, source archives, Flash
libraries and applications, or Ruby libraries to a Maven repository. A
Maven repository provides a platform for the storage, retrieval, and
management of binary software artifacts and metadata.

In Maven, every software artifact is described by an XML document
called a Project Object Model (POM). This POM contains information
that describes a project and lists a project's dependencies - the
binary software artifacts which a given component depends upon for
successful compilation or execution. 

When Maven downloads a dependency from a repository, it also downloads
that dependency's POM. Given a dependency's POM, Maven can then
download any other libraries which are required by that
dependency. The ability to automatically calculate a project's
dependencies and transitive dependencies is made possible by the
standard and structure set by the Maven repository.

Maven and other tools such as Ivy which interact with a repository to
search for binary software artifacts, model the projects they manage,
and retrieve software artifacts on-demand from a repository. When you
download and install Maven without any customization, Maven will
retrieve artifacts from a Maven Central repository which serves
millions of Maven users every single day. While you can configure
Maven to retrieve binary software artifacts from a collection of
mirrors, the best-practice is to install Nexus and use it to proxy and
cache the contents of Central on your own network. 

In addition to Central, there are a number of major organizations such
as Red Hat, Oracle, and Codehaus which maintain separate
repositories.

While this might seem like a simple, obvious mechanism for
distributing artifacts, the Java platform existed for several years
before the Maven project created a formal attempt at the first
repository for Java artifacts. Until the advent of the Maven
repository in 2002, a project's dependencies were gathered in a
manual, ad-hoc process and were often distributed with a project's
source code. As applications grew more and more complex, and as
software teams developed a need for more complex dependency management
capabilities for larger enterprise applications, Maven's ability to
automatically retrieve dependencies and model dependencies between
components became an essential part of software development.

==== Release and Snapshot Repositories

A repository stores two types of artifacts: releases and
snapshots. Release repositories are for stable, static release
artifacts and snapshot repositories are frequently updated
repositories that store binary software artifacts from projects under
constant development.

While it is possible to create a repository which serves both release
and snapshot artifacts, repositories are usually segmented into
release or snapshot repositories serving different consumers and
maintaining different standards and procedures for deploying
artifacts.  Much like the difference between a production network and
a staging network, a release repository is considered a production
network and a snapshot repository is more like a development or a
testing network.  While there is a higher level of procedure and
ceremony associated with deploying to a release repository, snapshot
artifacts can be deployed and changed frequently without regard for
stability and repeatability concerns.

The two types of artifacts managed by a repository manager are:

Release:: A release artifact is an artifact which was created by a
specific, versioned release. For example, consider the 1.2.0 release
of the commons-lang library stored in the Maven Central
repository. This release artifact, commons-lang-1.2.0.jar, and the
associated POM, commons-lang-1.2.0.pom, are static objects which will
never change in the Maven Central repository. Released artifacts are
considered to be solid, stable, and perpetual in order to guarantee
that builds which depend upon them are repeatable over time. The
released JAR artifact is associated with a PGP signature, an MD5 and
SHA checksum which can be used to verify both the authenticity and
integrity of the binary software artifact.

Snapshot:: Snapshot artifacts are artifacts generated during the
development of a software project. A Snapshot artifact has both a
version number such as "1.3.0" or "1.3" and a timestamp in its
name. For example, a snapshot artifact for commons-lang 1.3.0 might
have the name commons-lang-1.3.0-20090314.182342-1.jar the associated
POM, MD5 and SHA hashes would also have a similar name.  To facilitate
collaboration during the development of software components, Maven and
other clients which know how to consume snapshot artifacts from a
repository also know how to interrogate the metadata associated with a
Snapshot artifact to retrieve the latest version of a Snapshot
dependency from a repository.

A project under active development produces SNAPSHOT artifacts that
change over time. A release is comprised of artifacts which will
remain unchanged over time.

==== Repository Coordinates

Repositories and tools like Maven know about a set of coordinates
including the following components: groupId, artifactId, version, and
packaging. This set of coordinates is often referred to as a GAV
coordinate which is short for "Group, Artifact, Version
coordinate". The GAV coordinate standard is the foundation for Maven's
ability to manage dependencies. Four elements of this coordinate
system are described below:

groupId:: A group identifier groups a set of artifacts into a logical
group. Groups are often designed to reflect the organization under
which a particular software component is being produced. For example,
software components being produced by the Maven project at the Apache
Software Foundation are available under the groupId org.apache.maven.

artifactId:: An artifact is an identifier for a software component. An
artifact can represent an application or a library; for example, if
you were creating a simple web application your project might have the
artifactId "simple-webapp", and if you were creating a simple library,
your artifact might be "simple-library". The combination of groupId
and artifactId must be unique for a project.

version:: The version of a project follows the established convention
of Major, Minor, and Point release versions. For example, if your
simple-library artifact has a Major release version of 1, a minor
release version of 2, and point release version of 3, your version
would be 1.2.3. Versions can also have alphanumeric qualifiers which
are often used to denote release status. An example of such a
qualifier would be a version like "1.2.3-BETA" where BETA signals a
stage of testing meaningful to consumers of a software component.

packaging:: Maven was initially created to handle JAR files, but a
Maven repository is completely agnostic about the type of artifact it
is managing. Packaging can be anything that describes any binary
software format including ZIP, SWC, SWF, NAR, WAR, EAR, SAR.

==== Addressing Resources in a Repository

Tools designed to interact Maven repositories translate artifact
coordinates into a URL which corresponds to a location in a Maven
repository. If a tool such as Maven is looking for version 1.2.0 of
the commons-lang JAR in the group org.apache.commons, this request is
translated into:

----
<repoURL>/org/apache/commons/commons-lang/1.2.0/commons-lang-1.2.0.jar
----

Maven would also download the corresponding POM for commons-lang
1.2.0 from:

----
<repoURL>/org/apache/commons/commons-lang/1.2.0/commons-lang-1.2.0.pom
----

This POM may contain references to other dependencies which would then
be retrieved from the same repository using the same URL patterns.

==== The Maven Central Repository

The most useful Maven repository is the Central Repository. The
Central Repository is the largest repository for Java based components
and the default repository built into Apache Maven. Statistics about
the size of the Central Repository are available at
http://search.maven.org/#stats[http://search.maven.org/#stats]. You
can look at the Central Repository as an example of how Maven repositories
operate and how they are assembled. Here are some of the properties of
release repositories such as the Central Repository:

Artifact Metadata:: All software artifacts added to the Central
Repository require proper metadata including a Project Object Model
(POM) for each artifact which describes the artifact itself, and any
dependencies that software artifact might have.

Release Stability:: Once published to the Central Repository, an
artifact and the metadata describing that artifact never change. This
property of release repositories guarantees that projects which depend
on releases will be repeatable and stable over time. While new
software artifacts are being published every day, once an artifact is
assigned a release number on the Central Repository, there is a strict
policy against modifying the contents of a software artifact after a
release.

Repository Mirrors:: The Central Repository is a public resource, and
it is currently used by the millions of developers who have adopted
Maven and other build tools that understand how to interact with the
Maven repository structure. There are a series of mirrors for the
Central Repository which are constantly synchronized. Users are
encouraged to query for project metadata and cryptographic hashes and
they are encouraged to retrieve the actual software artifacts from one
of Central's many mirrors.  Tools like Nexus are designed to retrieve
metadata from the Central Repository and artifact binaries from
mirrors.

Artifact Security:: The Central Repository contains cryptographic
hashes and PGP signatures which can be used to verify the authenticity
and integrity of software artifacts served from Central or one of the
many mirrors of Central and supports connection to Central in a secure
manner via HTTP.

[[repoman-sect-repoman]]
=== What is a Repository Manager

If you use Maven, you are using a repository to retrieve artifacts and
Maven plugins. In fact, Maven used a Maven repository to retrieve core
plugins that implement the bulk of the features used in your
builds. Once you start to rely on repositories, you realize how easy
it is to add a dependency on an open source software library available
in the Maven Central repository, and you might start to wonder how you
can provide a similar level of convenience for your own
developers. When you install a repository manager, you are bringing
the power of a repository like Central into your organization, you can
use it to proxy Central, and host your own repositories for internal
and external use. In this section, we discuss the core functionality
which defines what a repository manager does.

Put simply, a repository manager provides two core features:

* The ability to proxy a remote repository and cache artifacts saving
  both bandwidth and time required to retrieve a software artifact
  from a remote repository, and

* The ability the host a repository providing an organization with a
  deployment target for software artifacts.

In addition to these two core features, a repository manager also
allows you to manage binary software artifacts through the software
development life-cycle, search and catalogue software artifacts, audit
development and release transactions, and integrate with external
security systems such as LDAP. The following sections define the
feature sets of Nexus Open Source and Nexus Professional.

==== Core Capabilities of a Repository Manager

The base-line features of a repository manager are a description of
the core capabilities of Nexus Open Source. Nexus Open Source provides
for the:

Management of Software Artifacts:: A repository manager is able to
manage packaged binary software artifacts. In Java development, this
would include JARs containing bytecode, source, or javadoc. In other
environments, such as Flex, this would include any SWCs or SWFs
generated by a Flex build.

Management of Software Metadata:: A repository manager should have
some knowledge of the metadata which describes artifacts. In a Maven
repository this would include project coordinates (groupId,
artifactId, version, classifier) and information about a given
artifact's releases.

Proxying of External Repositories:: Proxying an external repository
yields more stable builds as the artifacts used in a build can be
served to clients from the repository manager's cache even if the
external repository becomes unavailable. Proxying also saves bandwidth
and time as checking for the presence of an artifact on a local
network is often orders of magnitude faster than querying a heavily
loaded public repository

Deployment to Hosted Repositories:: Organizations which deploy
internal snapshots and releases to hosted repositories have an easier
time distributing software artifacts across different teams and
departments. When a department or development group deploys artifacts
to a hosted repository, other departments and development groups can
develop systems in parallel, relying upon dependencies served from
both release and snapshot repositories.

Searching an Index of Artifacts:: When you collect software artifacts
and metadata in a repository manager, you gain the ability to create
indexes and allow users and systems to search for artifacts. With the
Nexus index, an IDE such as Eclipse has almost instantaneous access to
the contents of all proxy repositories (including the Central
repository) as well as access to your own internal and 3rd party
artifacts. While the Central repository transformed the way that
software is distributed, the Nexus index format brings the power of
search to massive libraries of software artifacts.

Infrastructure for Artifact Management:: A repository manager should
also provide the appropriate infrastructure for managing software
artifacts and a solid API for extension. In Nexus, Sonatype has
provided a plugin API which allows developers to customize both the
behaviour, appearance, and functionality of the tool.

==== Additional Features of a Repository Manager

Once you adopt the core features of a repository manager, you start to
view a repository manager as a tool which enables more efficient
collaboration between development groups. Nexus Professional builds
upon the foundations of a repository manager and adds capabilities
such as Procurement and Staging.

Managing Project Dependencies:: Many organizations require some level
of oversight over the open source libraries and external artifacts
that are let into an organization's development cycle. An organization
could have specific legal or regulatory constraints which requires
every dependency to be subjected to a rigorous legal or security audit
before it is integrated into a development environment. Another
organization might have an architecture group which needs to make sure
that a large set of developers only has access to a well-defined list
of dependencies or specific versions of dependencies. Using the
Procurement features of Nexus Professional, managers and architecture
groups have the ability to allow and deny specific artifacts from
external repositories.

Managing a Software Release:: Nexus Professional adds some essential
work-flow to the process of staging software to a release
repository. Using Nexus Professional, developers can deploy to a
staging directory which can trigger a message to a Release Manager or
to someone responsible for QA. Quality assurance (or a development
manager) can then test and certify a release having the option to
promote a release to the release repository or to discard a release if
it didn't meet release standards. Nexus Professional's staging
features allow managers to specify which personnel are allowed to
certify that a release can be promoted to a release repository giving
an organization more control over what software artifacts are released
and who can release them.

Integration with LDAP:: Nexus integrates with an LDAP directory,
allowing an organization to connect Nexus to an existing directory of
users and groups. Nexus authenticates users against an LDAP server and
provides several mechanisms for mapping existing LDAP groups to Nexus
roles.

Advanced Security:: Using Nexus Professional provides the User Token
feature set. It removes the need for storing username and password
credentials in the Maven settings file replacing it with Nexus managed
token that can automatically be updated to the user's specific settings file
with the Maven settings integration. The tokens to not allow any
reverse engineering of the user name and password and therefore do not
expose these on the file system in the settings file in any form.

Settings Templates:: Nexus Professional allows you to define Maven
settings templates for developers. Developers can then automatically
receive updates to Maven settings (~/.m2/settings.xml) using the Maven
Nexus plugin. The ability to define Maven settings templates and to
distribute customized Maven settings files to developers makes it easy
for an organization to change global profiles or repository
configuration without relying on developers to manually install a new
settings file in a development environment.

Support for Multiple Repository Formats:: Nexus Professional supports
the P2 and the OSGi Bundle repository format used by the new Eclipse
provisioning platform and OSGi developers. You can use the P2 plugin
to consolidate, provision, and control the plugins that are being used
in an Eclipse IDE. Using Nexus procurement, repository groups, and
proxy repositories to consolidate multiple plugin repositories, an
organization can use Nexus Professional to standardize the
configuration of Eclipse IDE development environments.

Archive Browsing:: Nexus Professional allows users to browse the
contents of archives directly in the user interface as described in 
<<using-artifact-archive-browser>>.

[[repoman-sect-reasons]]
=== Reasons to Use a Repository Manager

Here are a few reasons why using a repository manager is an
imperative. While most people wouldn't even think of developing
software without the use of a source code control system like
Subversion or Perforce, the concept of using a repository manager is
still something that needs development. There are many who use Maven
for years without realizing the benefits of using a repository
manager. This section was written as an attempt to capture some of the
benefits of using a repository manager.

==== Speed Up Your Builds

When you run your multi-module project in Maven, how do you think
Maven knows if it needs to update plugins or snapshot dependencies? It
has to make a request for each artifact it needs to test. Even if
nothing has changed, if your project depends on a few SNAPSHOTs or if
you don't specify plugin version, Maven might have to make tens to
hundreds of requests to a remote repository. All of these requests
over the public Internet add up to real, wasted, time. I've seen
complex builds cut build time by 75% after installing a local instance
of Nexus.  You are wasting time better spent coding waiting for your
build to needlessly interrogate a remote Maven repository.

==== Save Bandwidth

The larger the organization, the more critical bandwidth savings can
be. If you have thousands of developers regularly wasting good
bandwidth to download the same files over and over again, using a
repository manager to keep a local cache is going to save you a good
deal of bandwidth. Even for smaller organizations with limited budgets
for connectivity and IT operations, having to deal with a set of
developers maxing out your connection to the Internet to download the
same things over and over again seems backwards.

==== Ease the Burden on Central

Running the Maven Central repository is no short order. It ain't cheap
to serve the millions of requests and Terabytes of data required to
satisfy the global demand for software artifacts from the Maven
Central repository. Something as simple as installing a repository
manager at every organization that uses Maven would likely cut the
bandwidth requirements for Central by at least half. If you have more
than a couple developers using Maven, install a repository manager for
the sake of keeping Central available and in business.

==== Gain Predictability and Scalability

How often in the past few years has your business come to a crashing
halt because of an outage? Depending on Central for your day to day
operations also means that you depend on having Internet connectivity
(and on the fact the Central will remain available 24/7).  While
Sonatype is confident in its ability to keep Central running 24/7, you
should take some steps of your own to make sure that your development
team isn't going to be surprised by some network outage on either
end. If you have a local repository manager, like Nexus, you can be
sure that your builds will continue to work even if you lose
connectivity.

==== Control and Audit Dependencies and Releases

So, you've moved over to Maven (or maybe Ivy, Ivy reads the same
repository), and you now have a whole room full of developers who feel
empowered to add or remove dependencies and experiment with new
frameworks. We've all seen this. We've all worked in places with a
developer who might be more interested in experimenting than in
working.  It is unfortunate to say so, but there are often times when
an architect, or an architecture group needs to establish some
baseline standards which are going to be used in an
organization. Nexus provides this level of control. If you need more
oversight over the artifacts that are making it into your
organization, take a look at Nexus. Without a repository manager, you
are going to have little control over what dependencies are going to
be used by your development team.

==== Deploy 3rd Party Artifacts

How do you deal with that one-off JAR from a vendor that is not open
source, and not available on the Maven Central repository? You need to
deploy these artifacts to a repository and configure your Maven
instance to read from that repository. Instead of hand-crafting some
POMs, download Nexus and take the two or three minutes it is going to
take to get your hands on a tool that can create such a repository
from 3rd-party artifacts. Nexus provides an intuitive upload form that
you can use to upload any random free-floating JAR that finds its way
into your project's dependencies.

==== Collaborate with Internal Repositories

Many organizations require every developer to checkout and build the
entire system from source simply because they have no good way of
sharing internal JARs from a build. You can solve a problem like this
by splitting projects up and using Nexus as an internal repository to
host internal dependencies.

For example, consider a company that has 30 developers split into
three groups of 10, each group focused on a different part of the
system. Without an easy way to share internal dependencies, a group
like this is forced either to create an ad hoc file-system-based
repository or to build the system in its entirety so that dependencies
are installed in every developer's local repository.

The alternative is to separate the projects into different modules
that all have dependencies on artifacts hosted by an internal Nexus
repository. Once you've done this, groups can collaborate by
exchanging compiled snapshot and release artifacts via Nexus. In other
words, you don't need to ask every developer to checkout a massive
multi-module project that includes the entire organization's
code. Each group within the organization can deploy snapshots and
artifacts to a local Nexus instance, and each group can maintain a
project structure which includes only the projects it is responsible
for.

==== Distribute with Public Repositories

If you are an open source project, or if you release software to the
public, Nexus can be the tool you use to serve artifacts to external
users. Think about it this way… When was the last time you cut a
release for your software project? Assuming it wasn't deployed to a
Maven repository, you likely had to write some scripts to package the
contents of the release, maybe someone special had to sign the release
with a super-secret cryptographic key. Then, you had to upload it to
some web server, and then make sure that the pages that describe the
upload were themselves updated. Lots of needless complexity…

If you were using something like Nexus, which can be configured to
expose a hosted repository to the outside world, you could use the
packaging and assembly capabilities of Maven and the structure of the
Maven repository to make a release that is more easily consumed. And,
this isn't just for JAR files and Java web applications; Maven
repositories can host any kind of artifact. Nexus, and Maven
repositories in general, define a known structure for releases. If you
are writing some Java library, publishing it to your own Nexus
instance serving a public repository will make it easier for people to
start using your code right away.

[[repoman-sect-adopting]]
=== Adopting a Repository Manager

This section talks about the stages of moving to a repository
manager. Adopting a repository manager is not an all or nothing
proposition, and there are various levels (or stages) of adoption that
can be distinguished when approaching repository management. On one
end of the adoption spectrum is the organization that installs a
repository manager just to control and consolidate access to a set of
remote repositories. On the other end of the spectrum is the
organization which has integrated the repository manager into an
efficient software development life-cycle, using it to facilitate
decision points in the life-cycle, encouraging more efficient
collaboration throughout the enterprise, and keeping detailed records
to increase visibility into the software development process.

==== Stage Zero: Before Using a Repository Manager

While this isn't a stage of adoption, Stage Zero is a description of
the way software builds work in the absence of a repository manager.
When a developer decides that a he needs a particular open source
software component, he will download it from the component's web site,
read the documentation, and find the additional software that his
components rely on (referred to as "dependencies"). Once he has
manually assembled a collection of dependencies from various open
source project web sites and proprietary vendors, he will place all
these components somewhere on the network so that he, his team
members, the build script, the QA team, and the production support
team can find it. At any time, other developers may bring in other
components, sometimes with overlapping dependencies, placing them in
different network locations.  The instructions to bring all of these
ad-hoc, developer-managed components libraries together in a software
build process can become very complicated and hard to maintain.

Maven was introduced to improve this build process by introducing the
concept of structured repositories from which the build scripts can
retrieve the software components. In Maven language, these software
components or dependencies are referred to as "artifacts", a term
which can refer to any generic software artifact including components,
libraries, frameworks, containers, etc. Maven can identify artifacts
in repositories, understand their dependencies, retrieve all that are
needed for a successful build, and deploy its output back to
repositories when done.

Developers using Maven without a repository manager find most of their
software artifacts and dependencies in Maven Central. If they happen
to use another remote repository or if they need to add a custom
artifact, the solution, in Stage Zero, is to manually manipulate the
files in a local repository and share this local repository with
multiple developers. While this approach may yield a working build for
a small team, managing a shared local repository doesn't allow an
organization to scale a development effort. There is no inherent
control over who can set up a local repository, who can add to them or
change or delete from them, nor are there tools to protect the
integrity of these repositories.

That is, until Repository Managers were introduced.

==== Stage One: Proxying Remote Repositories

This is the easiest stage to understand both in terms of benefits to
an organization and action required to complete this stage. All you
need to do to start Procyon a remote repository is to deploy Nexus
and start the server with the default configuration. Configure your
Maven clients to read from the Nexus public repository group, and
Nexus will automatically retrieve artifacts from remote repositories,
such as Maven Central, caching them locally.

Without a repository manager, your organization might have hundreds of
developers independently downloading the same artifacts from public,
remote repositories. With a repository manager, these artifacts can be
downloaded once and stored locally. After Stage One, your builds run
considerably faster than they did when you relied upon the Maven
Central repository.

Once you've installed Nexus and you've configured all of your
organization's clients to use it as a single point of access to remote
repositories, you begin to realize that it now provides you with a
central configuration point for the artifacts used throughout your
organization. Once you've started to proxy, you can start to think
about using Nexus as a tool to control policy and what dependencies
are allowed to be used in your organization. Nexus Professional
provides a procurement plugin which allows for fine-grained control
over which artifacts can be accessed from a remote repository. This
procurement feature is described in more detail in the section which
deals with Life-cycle Integration.

==== Stage Two: Hosting a Repository Manager

Once you have started to proxy remote repositories and you are using
Nexus as a single, consolidated access point for remote repositories,
you can start to deploy your own artifacts to Nexus hosted
repositories. Most people approach repository management to find a
solution for proxying remote repositories, and while proxying is the
most obvious and immediate benefit of installing a repository manager,
hosting internally generated artifacts tends to be the stage that has
the most impact on collaboration within an organization.

To understand the benefits of hosting an internal repository, you have
to understand the concept of managing binary software artifacts.
Software development teams are very familiar with the idea of a source
code repository or a source code management tool. Version control
systems such as Subversion, Clearcase, Git, and CVS provide solid
tools for managing the various source artifacts that comprise a
complex enterprise application, and developers are comfortable
checking source out from source control to build enterprise
applications. However, past a certain point in the software
development life-cycle, source artifacts are no longer relevant. A QA
department trying to test an application or an Operations team
attempting to deploy an application to a production network no longer
needs access to the source artifacts. QA and Operations are more
interested in the compiled end-product of the software development
life-cycle: the binary software artifacts. A repository manager allows
you to version, store, search, archive, and release binary software
artifacts derived from the source artifacts stored in a source control
system. A repository manager allows you to apply the same systematic
operations on binary software artifacts which you currently apply to
your source code.

When your build system starts to deploy artifacts to an internal
repository, it changes the way that developers and development groups
can interact with one another in an enterprise. Developers in one
development group can code and release a stable version of an internal
library, deploy this library to an internal Nexus release repository,
and so share this binary artifact with another group or department.
Without a repository manager managing internal artifacts, you have
ad-hoc solutions and the organizational equivalent of "duct tape". How
does the infrastructure group send a new library to the applications
group without Nexus? Someone copies a file to a shared directory, and
sends an email to the team lead. Organizations without repository
managers are full of these ad-hoc processes that get in the way of
efficient development and deployment.

With a repository manager, every developer and every development group
within the enterprise understands and interacts with a common
collaborative structure: the repository manager. Do you need to
interact with the Commerce team's new API? Just add a dependency to
your project and Maven will retrieve the library from Nexus
automatically.

One of the other direct benefits of deploying your own artifacts to a
repository such as Nexus is the ability to quickly search the metadata
and contents of those artifacts both via a web UI and through IDE
integration tools such as m2eclipse. When you start to deploy internal
artifacts you can synchronize all development groups to a common
version and naming standard, and you can use the highly
configurable authentication and role-based access controls to control
which developers and which development groups can deploy artifacts to
specific repositories or paths within a repository.

==== Stage Three: Continuous Collaboration

Developing this collaborative model further, if your application is
being continuously built and deployed using a tool like Hudson, a
developer can checkout a specific module from a large multi-module
build and not have to constantly deal with the entire source tree at
any given time. This allows a software development effort to scale
efficiently. If every developer working on a complex enterprise
application needs to checkout the entire source tree every time he or
she needs to make a simple change to a small component, you are
quickly going to find that building the entire application becomes a
burdensome bottleneck to progress. The larger your enterprise grows,
the more complex your application becomes, the larger the collective
burden of wasted time and missed opportunities. A slow enterprise
build prevents the quick turnaround or quick feedback loop that helps
your developers maintain focus during a development cycle.

Once you are building with Maven, sharing binary artifacts with Nexus,
continuously testing and deploying with Hudson, and generating reports
and metrics with tools like Sonar, your entire organization gains a
collaborative "central nervous system" that enables a more agile
approach to software development.

==== Stage Four: Life-cycle Integration

Once you've configured a repository manager to proxy remote
repositories and you are using a repository manager as an integration
point between developers and departments, you start to think about the
various ways your repository manager can be used to support the
decisions that go into software development. You can start using the
repository manager to stage releases and supporting the work-flow
associated with a managed release, and you can use the procurement
features of a tool like Nexus Professional to give management more
visibility into the origins, characteristics and open source licenses
of the artifacts used during the creation of an enterprise
application.

Nexus Professional enables organizations to integrate the management
of software artifacts tightly with the software development life-cycle:
Provisioning, Compliance, Procurement, Enterprise Security, Staging
and other capabilities that support the work-flow that surrounds a
modern software development effort.

Using Nexus Professional's Maven Settings management feature
and integrated security features you can configure a developer's
Maven settings by running a single, convenient Maven goal and
downloading customized settings for a particular developer. When
you use Maven and Nexus Professional together, developers can get
up and running quickly, collaborating on projects that share
common conventions without having to manually install dependencies
in local repositories.

Provisioning:: Using Nexus as an integration point between Engineering
and Operations means that Engineering can be responsible for
delivering solid, tested artifacts to Quality Assurance and Operations
via a standard repository format. Often development teams are roped
into the production deployment story and become responsible for
building entire production environments within a build system. This
conflates software engineering with system administration and blurs
the line between Engineering and Operations. If you use Nexus as a
end-point for releases from Engineering, Operations can then retrieve,
assemble, and configure an application from tested components in the
Nexus repository.

Compliance:: Procurement, staging, and audit logs are all features
which increase the visibility into who and what is involved with your
software development effort. Using Nexus Professional, Engineering can
create the reports and documents which can be used to facilitate
discussions about oversight.  Organizations subject to various
regulations often need to produce a list of components involved in a
software release. Legal departments often require a list of open
source licenses being used in a particular software component, and
managers often lack critical visibility into the software development
process.

Procurement:: The ease with which today's developer can add a
dependency on a new open source library and download this library from
a Central repository has a downside. Organizations large and small are
constantly wondering what open source libraries are being used in
applications, and whether these libraries have acceptable open source
licenses for distribution. The Procurement features of Nexus
Professional give architects and management more oversight over the
artifacts which are allowed into an organization. Using the
Procurement features, a Nexus administrator or Procurement manager can
allow or deny specific artifacts by group, version, or path. You can
use the procurement manager as a firewall between your own
organization's development environment and the 95,000 artifacts
available on the Maven Central repository.

Enterprise Security:: Nexus' LDAP integration allows an enterprise to
map existing LDAP groups to Nexus roles and provides Nexus
administrators with a highly configurable interface to control which
individuals or groups have access to a fine-grained set of Nexus
permissions.

Staging:: Nexus Professional adds an important step to the software
release work-flow, adding the concept of a managed (or staged) release
to a hosted repository. When a developer needs to perform a production
release, Nexus Professional can isolate the artifacts involved in a
release in a staged repository which can then be certified and
tested. A manager or a quality assurance tester can then promote or
discard a release. The staging feature allows you to specify the
individuals that are allowed to promote a release and keeps an audit
of who was responsible for testing, promoting, or discarding a
software release.
